package main

import (
	"bytes"
	"context"
	"fmt"
	"sync"
	"time"

	npb "github.com/SunSince90/go-naivecoin/pkg/networking/pb"
	"google.golang.org/grpc"
)

// Peer is a representation of other nodes.
type Peer struct {
	// Name of the peer.
	Name string
	// IP of the peer
	IP string

	// Address
}

// PeerEventType represents a type of event that could occur for a peer, i.e. when
// a new peer is found or when it is dead.
type PeerEventType string

const (
	// EventNewPeer represents an event about a new peer found.
	EventNewPeer PeerEventType = "NEW_PEER"
	// EventDeadPeer represents an event about a dead/dying peer.
	EventDeadPeer PeerEventType = "DEAD_PEER"

	// We don't really need an UPDATED_PEER as in this example project we are
	// running stateless loads on Kubernetes, thus they never change address
	// or name: when they die K8s will schedule a new pod with a new name and
	// new address.
	// This needs to be corrected in case the project is made to be
	// stateful.
)

// PeerEvent is a structure that is delivered to the channel.
type PeerEvent struct {
	// EventType is the type of the event occurring for this peer.
	EventType PeerEventType
	// Peer that caused this event.
	Peer *Peer
}

// PeersManager manages peers and peer events.
type PeersManager struct {
	peers  map[string]*Peer
	myself string
	myIP   string
	conns  map[string]npb.PeerCommunication_SubscribeNewBlocksClient
	lock   sync.Mutex
}

// NewPeersManager creates and returns a new instance of a PeersManager.
func NewPeersManager(myself, myIP string) *PeersManager {
	return &PeersManager{
		peers:  map[string]*Peer{},
		lock:   sync.Mutex{},
		myself: myself,
		myIP:   myIP,
		conns:  map[string]npb.PeerCommunication_SubscribeNewBlocksClient{},
	}
}

// ListenPeerEvents runs loop on the provided channel to wait for events
// about peers.
func (m *PeersManager) ListenPeerEvents(peerEvents chan PeerEvent) {
	for ev := range peerEvents {
		switch ev.EventType {

		case EventNewPeer:
			go m.parseNewPeerEvent(ev)

		case EventDeadPeer:
			go func() {
				m.lock.Lock()
				defer m.lock.Unlock()

				delete(m.peers, ev.Peer.Name)
				if conn := m.conns[ev.Peer.Name]; conn != nil {
					if err := conn.CloseSend(); err != nil {
						log.Err(err).Msg("could not close connection with peer")
					}
				}
			}()
		}
	}

	// Close all connections
	for peer, conn := range m.conns {
		if err := conn.CloseSend(); err != nil {
			log.Err(err).Str("peer", peer).Msg("could not close connection with peer")
		}
	}
}

func (m *PeersManager) parseNewPeerEvent(ev PeerEvent) {
	l := log.With().Str("event", "new-peer").
		Str("peer-name", ev.Peer.Name).
		Str("peer-ip", ev.Peer.IP).
		Logger()

	m.lock.Lock()
	_, exists := m.peers[ev.Peer.Name]
	m.lock.Unlock()
	if exists {
		l.Info().Msg("peer was already parsed once: stopping here...")
		return
	}

	peerLastBlock, err := m.getLastBlockFromPeer(ev.Peer)
	if err != nil {
		l.Err(err).Msg("could not get last block from peer")
		return
	}
	myLastBlock := blockchain.GetLastBlock()

	diff, err := m.parseBlocksDifference(myLastBlock, *peerLastBlock)
	if err != nil {
		l.Err(err).Msg("peer's block is invalid: will not listen for blocks generated by this peer")
		return
	}

	m.lock.Lock()
	m.peers[ev.Peer.Name] = ev.Peer
	m.lock.Unlock()

	if *diff < 0 {
		peerBlockChain, err := m.getFullBlockChainFromPeer(ev.Peer)
		if err != nil {
			l.Err(err).Msg("could not get full blockchain from peer")
			return
		}

		if err := blockchain.ReplaceWith(peerBlockChain); err != nil {
			l.Err(err).Msg("could not replace chain with peer's chain")
			return
		}
	}

	go m.listenBlockGenerationFromPeer(*ev.Peer)
}

func (m *PeersManager) parseBlocksDifference(source, target Block) (*int64, error) {
	log.Info().Int64("my-last-block", source.Index).Int64("peer-last-blic", target.Index).Msg("got difference")
	switch diff := source.Index - target.Index; {

	// Same block
	case diff == 0:

		if !bytes.Equal(source.Hash, target.Hash) {
			return nil, fmt.Errorf("peer's last block hash is invalid")
		}

		if !bytes.Equal(source.PreviousBlockHash, target.PreviousBlockHash) {
			return nil, fmt.Errorf("peer's previous block hash is invalid")
		}

		return &diff, nil

	// Their last block is lower than mine
	case diff > 0:
		return &diff, nil

	// Their last block is greater than mine
	default:
		// case diff < 0:
		return &diff, nil
	}
}

func (m *PeersManager) listenBlockGenerationFromPeer(peer Peer) {
	l := log.With().
		Str("peer-name", peer.Name).
		Str("peer-ip", peer.IP).
		Logger()

	l.Info().Msg("listening for blocks from peer...")

	conn, err := grpc.Dial(fmt.Sprintf("%s:%d", peer.IP, 8082), grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		log.Err(err).Msg("could not contact peer for listening on block generation")
		return
	}
	defer conn.Close()

	cli := npb.NewPeerCommunicationClient(conn)

	sub, err := cli.SubscribeNewBlocks(context.Background(), &npb.SubscribeNewBlocksParams{})
	if err != nil {
		log.Err(err).Msg("could not subscribe to peer")
		return
	}

	m.lock.Lock()
	m.conns[peer.Name] = sub
	m.lock.Unlock()

	for {
		block, err := sub.Recv()
		if err != nil {
			l.Err(err).Msg("error while getting block from peer")
			continue
		}

		l.Info().Int64("index", block.Index).Str("data", block.Data).Msg("got block from peer")
	}
}

func (m *PeersManager) getLastBlockFromPeer(peer *Peer) (*Block, error) {
	conn, err := grpc.Dial(fmt.Sprintf("%s:%d", peer.IP, 8082), grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		return nil, err
	}
	defer conn.Close()

	cli := npb.NewPeerCommunicationClient(conn)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	b, err := cli.GetLatestBlock(ctx, &npb.GetLatestBlockParams{})
	if err != nil {
		return nil, err
	}

	log.Info().Msg("retrieved last block from peer")

	return &Block{
		Index:             b.Index,
		Timestamp:         b.Timestamp,
		PreviousBlockHash: b.PreviousBlockHash,
		Data:              b.Data,
		Hash:              b.Hash,
	}, nil
}

func (m *PeersManager) getFullBlockChainFromPeer(peer *Peer) ([]Block, error) {
	conn, err := grpc.Dial(fmt.Sprintf("%s:%d", peer.IP, 8082), grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		return nil, err
	}
	defer conn.Close()

	cli := npb.NewPeerCommunicationClient(conn)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	bc, err := cli.GetFullBlockChain(ctx, &npb.GetFullBlockChainParams{})
	if err != nil {
		return nil, err
	}

	blocks := make([]Block, len(bc.Blocks))
	for i, block := range bc.Blocks {
		blocks[i] = *ToBlock(block)
	}

	return blocks, nil
}
